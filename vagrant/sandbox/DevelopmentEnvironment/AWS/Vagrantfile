# -*- mode: ruby -*-
# vi: set ft=ruby :

#-------------------------------------------------------------------------------
# README
#
# This Vagrantfile is designed to instantiate an Evernym Development Environment
# using AWS as the vagrant provider and automates the following:
#
#  1. Clone all the required source code from github, or use clones you have
#     already created.
#    1.1. Source code should reside in your desktop environment and be available
#         in the AWS VM as an rsync-ed folder. This allows the developer the
#         option of using an IDE in their own graphical desktop environment with
#         their own license. You will need to get familiar with rsync to resync
#         folders during the code-build-test cycle.
#    1.2. If you have not already cloned source, this Vagrant file assumes that
#         you have already forked the project and will prompt you for a username
#         and clone from "https://github.com/<username>/<project>.git" where
#         <username> is your username, and <project> is the target repo(s).
#  2. Install build tools/dependencies.
#  3. (Optional) Build source code on 'vagrant up'. Defaults to (N)o.
#  4. (Optional) Run unit tests on 'vagrant up'. Defaults to (N)o.
#  5. (Optional) Deposit artifacts in an S3 bucket when build and test pass on
#                'vagrant up'. Defaults to (N)o. Must answer Y to both build and
#                test for this to be an option. TODO: decide how to configure
#                the S3 bucket or other deposit location.
#
# Prerequisites:
#
# You must complete all of these steps before running vagrant commands.
#
#  1. Install Vagrant
#
#  2. Install the vagrant-aws plugin
#      https://github.com/mitchellh/vagrant-aws/blob/master/README.md 
#
#     Run the following from the command line:
#     $ vagrant plugin install vagrant-aws
#
#  3. Add a Vagrant box for use by this Vagrantfile
#     Option 1: (recommended/default) Use the vagrant-aws plugin provided box.
#       This option requires that you specifying all the AWS provider details
#       within the config.vm.profider block.
# 
#       $ vagrant box add dummy https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box
#
#       Proceed to complete the "Configure the AWS Vagrant provider" step below.
#
#     Option 2: Create your own AWS Vagrant box:
#         2.1 Follow these instructions:
#           https://github.com/mitchellh/vagrant-aws/tree/master/example_box
#         2.2 Change config.vm.box = "dummy" in the Vagrant.configure block
#           below to the name of the Vagrant box you created and added.
#         2.3 Comment out any Vagrant.configure settings that you built into
#           your own AWS Vagrant box.
#         2.4 Skip steps in the "Configure the AWS Vagrant provider" step below
#           that are handled by your own AWS Vagrant box.
#
#  4. Configure the AWS Vagrant provider:
#     The title of each of the following steps has a corresponding section
#     in the Vagrant provider (config.vm.provider) portion of the
#     Vagrant.configure block below. Simply search for "----- <title> -----" to
#     Jump to the corresponding configuration settings.
#
#     4.1 - Authentication and Authorization
#       IMPORTANT: You can choose your AWS profile and files location by using
#       aws.aws_profile and aws.aws_dir, however environment variables will
#       always have precedence as defined by the AWS documentation. Therefore,
#       if you choose Option 2, be sure environment variables are NOT set, or
#       you could comment out Option 2 and use the environment variables to
#       configure your Access Key.
# 
#       You have 3 options when configuring AWS authentication/authorization:
#         Option 1: AWS Profile (default - recommended)
#           1.1 Follow instructions to setup the AWS cli:
#             http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html
#           1.2 Create a profile and note the name.
#           1.3 Replace <PROFILE> below with the name.
#         Option 2: Access Key
#           2.1 Comment out Option 1 and uncomment Option 2 in the
#               Vagrant.configure block below.
#           2.2 Follow the "To get the access key ID and secret access key for
#             an IAM user" instructions at the following URL if you don't
#             already have an Access Key:
#             http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html
#           2.3: Replace <YOUR KEY>, <YOUR SECRET KEY>, and <REGION> in Option 2
#             below. NOTE: Keep your keys safe. Do NOT commit these changes to
#             git!
#         Option 3: Session Token - A Session Token Service token.
#           3.1 Replace <SESSION TOKEN> and <REGION> in Option 3 in the
#             Vagrant.configure block below. NOTE: Keep your session tokens
#             safe. Do NOT commit these changes to git! Even if a session token
#             has a very limited lifetime.
#     4.2 - Security Groups
#       Replace or delete <SECURITY GROUP>. At minimum, the security group(s)
#       must allow SSH (inbound/outbound)
#     4.3 - Regions
#       AMIs are based on the region you have configured. The AMI IDs are
#       subject to change. Therefore, find the AMI you want to use in the the
#       desired region. Refer to the following documentation to find an AMI
#       for a given region:
#         http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html
#       Key pairs are also region specific. Set the <KEY PAIR NAME> for each
#       region you configure. The <KEY PAIR NAME> key must be defined in
#       NETWORK & SECURITY in the EC2 Management Console. If you don't have a
#       key pair defined, run ssh-kegen on your workstation and upload the
#       public key to NETWORK & SECURITY > Key Pairs in the EC2 Management
#       Console in the target region. You will set the SSH private key path in
#       the SSH step below.
#     4.4 - Instance Type
#       Size your VM. Refer to the following documentation to find a suitable
#       instance type:
#         http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html
#     4.5 - SSH
#       We are using an SSH keypair where the public key exists in
#       EC2 Management Console > NETWORK & SECURITY > Key Pairs. It is possible
#       that each region (see Regions above) could have a different
#       key pair (keypair_name). Therefore, add all private keys to the
#       override.ssh.private_key_path array.
#
#  5. Install Git
#
# How to use:
# Run 'vagrant up' and answer any questions this Vagrantfile or the Vagrant VM
# instance (i.e. network bridge) needs to complete the process. If you run into
# problems (i.e. shared folders, etc.), try 'vagrant reload --provision'. Doing
# so will restart the VM and re-run the provisioning script. A slightly more
# expensive operation would be to 'vagrant destroy' followed by 'vagrant up'.
#
# Some details to be aware of:
#  1. All files and folders in the Vagrant project folder show up as shared
#     resources in /vagrant on all Vagrant VM(s)/guests instantiated by this
#     Vagrantfile. This is a design descision made by the Vagrant folks for the
#     Virtualbox provider. To be consistent with that in the AWS provider, the
#     contents the Vagrant project folder will be shared (rcync-ed) to /vagrant
#     inside guest VMs.
#  2. Source code will be cloned into this Vagrant project folder using the git
#     project name and then shared in /src/<git project name> in the Vagrant
#     guest VM(s). The .gitignore file in this Vagrant project folder ignores
#     these folders.
#  3. If you have your own source code clones, a symbolic link is
#     created in this Vagrant project folder. Doing so simplifies some discovery
#     logic in this Vagrantfile (ruby script). A side-effect of symlinking in
#     this Vagrant project folder is that the symlink is broken inside the
#     AWS VM. Please do not remove or try to fix broken symlinks in /vagrant in
#     the AWS VM(s). And be assured that the source code associated with the
#     symlinks on your Vagrant host are available in /src/<git project name> in
#     your Vagrant VM(s).

#-------------------------------------------------------------------------------
# Variable defaults

development_branch            = `git rev-parse --abbrev-ref HEAD`
development_run_build         = 'N'
development_run_tests         = 'N'
development_deposit_artifacts = 'N'
development_run_cleanup       = 'N'

#-------------------------------------------------------------------------------
# Define development repos and setup default shared folder path.

# Code should reside on the Vagrant host and be rsync-ed to the Vagrant VM
# using Vagrant's shared folder feature (uni-directional) on vagrant up,
# vagrant reload, and vagrant provision. Doing so allows a developer to use
# their favorite IDE/tools to write code and have a cheap, fast way to build and
# test their changes.

# If you do not want to develop one or more of the following repos, you can
# either remove a repo from the following associative array or can "Skip" the
# repo when prompted.
development_repos      = {
  "sovrin" => "/vagrant/sovrin",
  "indy-sdk" => "/vagrant/indy-sdk"
}

# - Pseudocode -
# For each 'repo' in development_repos
#   Detect 'repo' in Vagrant project directory root
#     If 'repo' detected
#       Use the default directory path when defining synced folder
#     Else
#       Prompt the user for one of two options:
#         Option 1: Skip - I will not be developing 'repo'
#           Go to next repo
#         Option 2: Enter path of 'repo' git clone on Vagrant host 
#           Update the <path> for 'repo' => <path> in the development_repos
#           associative array
#         Option 3: Clone 'repo' for me. Note that this option requires that you
#                   to have a fork of the 'repo' codebase on github. The clone
#                   will be created in the root of this Vagrant project.
#                   - This option prompts the user for their github userid and
#                     builds the 'repo' URL.
#                   - It is important to note that the project default branch is
#                     the active branch after the clone is complete. It is up to
#                     the developer to change the branch if the project's default
#                     branch is not the branch they want.
#           Clone the repo
#             If failed to clone (404, etc.)
#               Exit with a verbose error message
username = ""
filtered_development_repos = {}
development_repos.each_pair { |key, value| 
  filepath = File.expand_path(File.dirname(__FILE__))
  directory = File.join("#{filepath}", "#{key}")
  #puts "Check if directory #{directory} exists ..."
  if File.directory?("#{directory}")
    #puts "Directory #{directory} exists. Will rsync #{directory} to "\
    #  "/src/#{key}"
    filtered_development_repos["#{key}"] = "#{directory}"
  else
    prompt = "> "
    puts "Unable to detect a clone of repo '#{key}'. What would you like to do?"
    puts "\t1. Skip - I will not be developing/testing code for #{key}."
    puts "\t2. Enter a full path to repo '#{key}' on my Vagrant host."
    puts "\t3. I have forked '#{key}'. Clone it for me."
    print prompt

    loop do
      user_input = $stdin.gets.chomp
      case user_input
      when "1"
        puts "Skipping ..."

        # Create an empty directory using the repo name (key) so the developer is
        # never prompted again. TODO: use properties file to manage the Skip
        # feature (and others).
        Dir.mkdir(key) unless Dir.exist?(key)

        # Write a README file to the empty directory informing them
        File.open("#{key}/README", "w") {
          |f| f.write('You chose to skip this codebase. If you change your mind'\
          ', do the following:' + "\n\n" + '1. Delete this directory.' + "\n" +
          '2. Run \'vagrant reload --provision\' -OR- \'vagrant destroy &&'\
          ' vagrant up\'')
        }
        break
      when "2"
        puts "Enter a full path to repo '#{key}' on your Vagrant host."
        print prompt 
        absolute_path = $stdin.gets.chomp
        if !File.directory?(absolute_path)
          $stderr.puts "#{absolute_path} does not exist."
          exit 1
        else
          puts "Verified #{absolute_path} exists ..."
        end
        puts "Creating symbolic link '#{key}' in Vagrant project to #{absolute_path} ..."
        require 'open3'
        stdout, stderr, status = Open3.capture3("ln -sf #{absolute_path} #{directory}")
        if status.exitstatus != 0
          $stderr.puts "Failed to create sybolic link"
          $stderr.puts stderr
          exit 1
        end
        filtered_development_repos[key] = absolute_path
        break
      when "3"
        if username == ""
          puts "Enter your github username."
          print prompt 
          username = $stdin.gets.chomp
        end
        url = "https://github.com/#{username}/#{key}.git"
        puts "Cloning repo '#{url}' on your Vagrant host."
        puts "The default project branch will be checked out. Please be sure you "\
          "are on the branch you want."
        require 'open3'
        stdout, stderr, status = Open3.capture3("git clone #{url}")
        if status.exitstatus != 0
          $stderr.puts "Failed to clone #{url}"
          $stderr.puts stderr
          exit 1
        end
        filtered_development_repos[key] = value
        break
      else
        puts "Please select either 1, 2, or 3"
        print prompt
      end
    end
  end
}

if ARGV.include?("up")
  development_run_cleanup = "Y"
end

if ARGV.include?("up") || ARGV.include?("provision") || ARGV.include?("--provision")
  puts "Bringing up VM(s) ..."
  prompt = "> "
  puts "Build source? (y/N)"
  print prompt

  loop do
    user_input = $stdin.gets.chomp
    case user_input
    when "Y", "y"
      puts "Code will be built during VM provisioning ..."
      development_run_build = "Y"
      break
    when "N", "n", ""
      puts "Code will NOT be built during VM provisioning ..."
      development_run_build = "N"
      break
    else
      puts "Please enter Y, y, N, or n"
      print prompt
    end
  end

  # Only run tests if a build will be performed.
  puts development_run_build
  if development_run_build == "Y"
    puts "Run tests? (y/N)"
    print prompt

    loop do
      user_input = $stdin.gets.chomp
      case user_input
      when "Y", "y"
        puts "Test will be run during VM provisioning ..."
        development_run_tests = 'Y'
        break
      when "N", "n", ""
        puts "Tests will NOT be run during VM provisioning ..."
        development_run_tests = 'N'
        break
      else
        puts "Please enter Y, y, N, or n"
        print prompt
      end
    end
  end
end

#-------------------------------------------------------------------------------
# Define the provisioning script
$script = <<SCRIPT
#!/bin/bash -e

USER='ec2-user'
BRANCH=$1
RUN_BUILD=$2
RUN_TESTS=$3
RUN_CLEANUP=$4
echo "Setting up development environment for branch $BRANCH"
echo "Run build? $RUN_BUILD"
echo "Run tests? $RUN_TESTS"
echo "Run cleanup? $RUN_CLEANUP"

#--------------------------------------------------------
echo 'Setting Up Networking'
if [ -f /vagrant/etc/hosts ]; then
  cp /vagrant/etc/hosts /etc/hosts
fi
perl -p -i -e 's/(PasswordAuthentication\s+)no/$1yes/' /etc/ssh/sshd_config
service sshd restart

#--------------------------------------------------------
echo "Installing Required Packages"
yum update -y

# TODO: When/If we need a full-blown development environment on AWS Linux
#   1. Figure out how to install Sovrin CLI or build it from source.
#   2. Figure out how to install docker-ce. Current missing rpm deps...
#     https://docs.docker.com/engine/installation/linux/docker-ce/centos/#set-up-the-repository

#--------------------------------------------------------
# Install Rust and rustup
#
# The following part of this script was derived from:
# "Setup Indy SDK build environment for RHEL based distro (Amazon Linux 2017.03)"
# https://github.com/hyperledger/indy-sdk/blob/master/doc/rhel-build.md

echo "Installing Rust and rustup non-interactively as ${USER}..."
echo "Note that rustup typically runs interactively and allows you to "
echo "customize installation. Defaults are used in this case. You can "
echo "reinstall Rust and rustup if you would like. See the following URL "
echo "for details: https://www.rust-lang.org/install.html"

curl https://sh.rustup.rs -sSf > rust.install.sh
chmod u+x ./rust.install.sh
chown $USER:$USER ./rust.install.sh
su -c "./rust.install.sh -y" $USER

#--------------------------------------------------------
# Install dev tools and other dependencies. Yum commands can be combined, but
# are intentially kept separate to make it clear what code requires what
# dependencies.
yum clean all
yum upgrade -y
yum groupinstall -y "Development Tools"
# Required for libindy
yum install -y \
    wget \
    cmake \
    pkgconfig \
    openssl-devel \
    sqlite-devel \
    docker

# Required for Sovrin client
yum install -y \
    curl \
    dialog \
    figlet

# Sovrin client requires Python 3.5.2 or later.
# IMPORTANT - python35-devel installs Python 3.5.1. The plenum code has a
# problem with functions in Unions.
#
# https://github.com/python/typing/issues/229
#
# $ python3.5 --version
# Python 3.5.1
#
# >>> from plenum.server.router import Router
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
#   File "/usr/local/lib/python3.5/site-packages/plenum/server/router.py", line 6, in <module>
#     Route = Tuple[Union[type, NamedTuple], Callable]
#   File "/usr/lib64/python3.5/typing.py", line 537, in __getitem__
#     dict(self.__dict__), parameters, _root=True)
#   File "/usr/lib64/python3.5/typing.py", line 467, in __new__
#     params.append(_type_check(p, msg))
#   File "/usr/lib64/python3.5/typing.py", line 299, in _type_check
#     raise TypeError(msg + " Got %.100r." % (arg,))
# TypeError: Union[arg, ...]: each arg must be a type. Got <function NamedTuple at 0x7f7631008378>.
#
# Removed python35-pip and python35-devel from yum install above.
#
# Required for Sovrin client
# yum install -y \
#    curl \
#    dialog \
#    figlet #\
#    #python35-pip \
#    #python35-devel

# Install Python 3.5.2 from source
# IMPORTANT: The Sovrin client expects to find python3.5 in /usr/bin. Set the
#            prefix to /usr.
cd /src
curl https://www.python.org/ftp/python/3.5.4/Python-3.5.4.tgz | tar -xz
cd Python-3.5.4
./configure --prefix=/usr
make
make install

# Useful dev utils
# Some of these may have already been installed by Development Tools
# groupinstall above.
yum install -y \
    mlocate \
    unzip \
    make \
    screen \
    tmux \
    vim

#--------------------------------------------------------
# Build and install modern version of libsodium from sources:
echo "Build and install libsodium 1.0.12..."
cd /src
curl https://download.libsodium.org/libsodium/releases/libsodium-1.0.12.tar.gz | tar -xz
cd /src/libsodium-1.0.12
./configure
make
make install

# Add exports to $USER's .bash_profile and current env
echo "Add exports to $USER's .bash_profile..."
user_bash_profile="/home/$USER/.bash_profile"
declare -a exports=(
 'export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig'
 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib'
)
for exp in "${exports[@]}"
do
  if ! grep -q "$exp" "$user_bash_profile"; then
    echo "Adding '${exp}' to $user_bash_profile"
    echo "$exp" >> "$user_bash_profile"
    echo "Executing '${exp}'"
    $exp
  else
    echo "$exp already found in $user_bash_profile"
  fi
done

#--------------------------------------------------------
# Sovrin Client - Prerequsites
echo "Install Sovrin CLI prerequisites..."
mkdir /home/$USER/sovrin-cli && cd /home/$USER/sovrin-cli
git clone https://github.com/hyperledger/indy-anoncreds.git && cd indy-anoncreds
sed -i -- 's#if \\[ -f /etc/redhat-release \\]#if \\[ -f /etc/redhat-release \\] \\|\\| grep -q "Amazon Linux AMI" /etc/os-release#' ./setup-charm.sh

# Comment taken from ./setup-charm.sh
#
# Ensure that you are using pip3.5 for installation.
# Use link to refer pip3.5 using pip command
#
# Ugg!
#
# We installed Python 3.5 from source (3.5.2 or later). The default prefix
# installation location is /usr/local.
#
# TODO: Figure out how to activate a Python virtualenv on 'vagrant up' (non
#       interactive shell)
ln -sf /usr/bin/pip3.5 /usr/bin/pip
./setup-charm.sh

#--------------------------------------------------------
# Setup a Python virtual environment with Python 3.5 or 3.6
#cd /home/$USER
#echo "Setup and activate a Python virtual environment..."
#virtualenv -p python3.5 sovrin-client
#source ./sovrin-client/bin/activate

#--------------------------------------------------------
# Install sovrin client in the Python virtual environment
echo "Install sovrin (CLI) client..."
pip install sovrin

#--------------------------------------------------------
echo "Install Docker SDK for Python..."
pip install docker
echo "Start docker service..."
chkconfig docker on
service docker start

#--------------------------------------------------------
# Build
if [ "$RUN_BUILD" == "Y" ]; then
  # Only build indy-sdk if the source is present.
  if [ -d "/src/indy-sdk" ]; then
    cd /src/indy-sdk/libindy
    su -c "/home/$USER/.cargo/bin/cargo build" $USER
  fi
fi

#--------------------------------------------------------
# Run tests?
if [ "$RUN_TESTS" == "Y" ]; then
  echo "Running tests..."
  # Only run indy-sdk tests if the source is present
  if [ -d "/src/indy-sdk" ]; then
    echo "Running indy-sdk tests..."
    cd /src/indy-sdk
    /vagrant/common/indypool.py start
    cd /src/indy-sdk/libindy
    su -c "RUST_TEST_THREADS=1 /home/$USER/.cargo/bin/cargo test" $USER
  fi
fi

#--------------------------------------------------------
if [ "$RUN_CLEANUP" == "Y" ]; then
  echo 'Cleaning Up...'
  rm -rf /src/libsodium-1.0.12
  rm -rf /src/Python-3.5.4
fi

#--------------------------------------------------------
echo "Post-Build/Test setup..."
if [ -d "/src/indy-sdk" ]; then
  echo "Making sure indy_pool is running ..."
  /vagrant/common/indypool.py start

  echo "Setting up vagrant user's .bash_profile to use indy-sdk Python bindings ..."
  # Only add indy-sdk python wrappers to the PTHONPATH if indy-sdk source is
  # present.

  # Add exports to $USER's .bash_profile and current env
  declare -a exports=(
    'export PYTHONPATH=$PYTHONPATH:/src/indy-sdk/wrappers/python'
    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/src/indy-sdk/libindy/target/debug'
  )
  for exp in "${exports[@]}"
  do
    if ! grep -q "$exp" "$user_bash_profile"; then
      echo "Adding '${exp}' to $user_bash_profile"
      echo "$exp" >> "$user_bash_profile"
      echo "Executing '${exp}'"
      $exp
    else
      echo "$exp already found in $user_bash_profile"
    fi
  done
fi

#--------------------------------------------------------
echo "Setup default .vimrc ..."
echo ":set colorcolumn=80" >> /home/$USER/.vimrc

yum update -y
updatedb
SCRIPT

Vagrant.configure("2") do |config|
  # TODO: Decide if we want to create our own Vagrant box with our own defaults.
  # ----- Vagrant Box -----
  config.vm.box = "dummy"

  # ----- Provider -----
  config.vm.provider :aws do |aws, override|
    # ----- Authentication and Authorization -----
    # Option 1: AWS Profile
    aws.aws_profile = "vagrantDevAWS"
    #aws.aws_profile = "<PROFILE>"

    # Option 2: Access Key
    #aws.access_key_id = "<YOUR KEY>"
    #aws.secret_access_key = "<YOUR SECRET KEY>"
    #aws.region = "<REGION>"

    # Option 3: Session Token - A Session Token Service token
    #aws.session_token = "<SESSION TOKEN>"
    #aws.region = "<REGION>"

    # ----- Security Groups -----
    aws.security_groups = ["default", "Temp Dev"]
    #aws.security_groups = ["default", "<SECURITY GROUP>"]

    # ----- SSH -----
    # We are using an SSH keypair where the public key exists in
    # EC2 Management Console > NETWORK & SECURITY > Key Pairs
    # Do NOT use Vagrant key pairs!
    override.ssh.keys_only = false
    
    # It is possible that each region (see Regions below) could have a different
    # key pair (keypair_name). Therefore, add all private keys to the
    # override.ssh.private_key_path array.
    #
    # Varant will try them in the order they appear in private_key_path until
    # one works or it runs out of keys.
    #
    # The insecure_private_key is vagrant's default key and should NOT be
    # relied on for AWS work.
    override.ssh.username = "ec2-user"
    override.ssh.private_key_path = [
      "~/.ssh/id_rsa",
      "~/.vagrant.d/insecure_private_key"
    ]

    # ----- Regions -----
    # The region in which the VM will be instantiated is defined by one of the
    # following.
    # 1. The AWS_DEFAULT_REGION environment variable
    #      http://docs.aws.amazon.com/cli/latest/userguide/cli-environment.html
    # 2. The 'region' defined in the aws.aws_profile
    # 3. aws.region
    # 4. The Vagrant AWS plugin's default: us-east-1
    #
    # Environment variables take precedence over everything else and the Vagrant
    # AWS plugin's default is used if not set. All other options override one
    # another with the last definition being used.
    #
    # Add additional regions as needed. If an additional region is needed:
    # 1. Copy the "Template" below.
    # 2. Replace <REGION NAME>
    # 3. Look up the <AMI ID> for the region
    #   3.1 AWS provided AMIs
    #     http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html
    #   3.2 Your own AMIs
    #     https://<REGION>.console.aws.amazon.com/ec2/v2/home?region=<REGION>#Images:sort=name
    # 4. Look up the <KEY PAIR NAME> for the region.
    #     https://<REGION>.console.aws.amazon.com/ec2/v2/home?region=<REGION>#KeyPairs:sort=keyName
    # 5. region_config does not allow us to set private_key_path for each
    #    region_config's keypair_name. You MUST add the private key path for
    #    region.keypair_name to the override.ssh.private_key_path array above!
    #
    # Template:
    #
    # aws.region_config "<REGION NAME>" do |region|
    #   region.ami = "<AMI ID>"
    #   region.keypair_name = "<KEY PAIR NAME>"
    # end

    aws.region_config "us-west-2" do |region|
      # Amazon Linux AMI (HVM), SSD Volume Type
      # US West Oregon - as of Oct 25, 2017
      region.ami = "ami-e689729e"
      region.keypair_name = "corin"
    end

    # ----- Instance Type -----
    # 1 vCPU .5 GiB - THIS IS TOO SMALL TO BUILD! DON'T USE IT
    #aws.instance_type = "t2.nano"

    # 1 vCPU 1 GiB - THIS IS TOO SMALL TO BUILD! DON'T USE IT
    # aws.instance_type = "t2.micro"

    # 1 vCPU 2 GiB RAM 8 GiB Disk
    # 8 GiB Disk is too small. Use block device mapping below to set the volume
    # size to 16 GiB
    aws.instance_type = "t2.small"

    # ----- Block Device Mapping -----
    aws.block_device_mapping = [
      {
        'DeviceName' => '/dev/xvda',
        'Ebs.VolumeSize' => 16
      }
    ]  
  end

  # ----- Vagrant VM -----
  config.vm.define "aws.lambda.development" do |development|
    # ----- Provisioning -----
    development.vm.provision "shell" do |s|
      s.inline = $script
      s.args   = [
        development_branch,
        development_run_build,
        development_run_tests,
        development_run_cleanup
      ]
    end

    # ----- Setup rcync-ed directories -----
    filtered_development_repos.each do |key, value|
      #print "Setup rsync-ed folder: development.vm.synced_folder '#{value}', '/src/#{key}', type: 'rsync'\n"
      development.vm.synced_folder "#{value}", "/src/#{key}", type: "rsync"
    end

    # Include all files and folders in the Vagrant project root. This provides a
    # consistent behavior with the other providers (i.e. Virtualbox).
    development.vm.synced_folder Dir.pwd, "/vagrant", type: "rsync"

    # Include all DevelopmentEnvironment common scripts/tools. These tools will
    # be referenced with an absolute path in the guest VM.
    development.vm.synced_folder Dir.pwd + "/../common", "/vagrant/common", type: "rsync"
  end
end
